{"./":{"url":"./","title":"简介","keywords":"","body":"快速入门React WxEAP 不知大家学 React 时会不会有这样的疑惑： ES6 特性那么多，我需要全部学会吗? React Component 有 3 种写法，我需要全部学会吗? Reducer 的增删改应该怎么写? 怎么做全局/局部的错误处理? 怎么发异步请求? 怎么处理复杂的异步业务逻辑? 怎么配置路由? ... 这篇文档梳理了基于React WxEAP的移动Web开发的最小知识集，让你可以用最少的时间掌握开发技巧，并且不需要掌握额外的冗余知识。当然，如果想深入了解前端技术，可以阅读WxDocs的其他文档。 本教程循序渐进地分为三个部分： 基础知识 开发框架 具体流程 环境需求 React WxEAP开发环境可以跟WxEAP不在一台主机下，要求如下： Node.js Chrome Visual Studio Code TortoiseSVN 源代码管理 SVN地址 http://192.168.0.7:8080/svn/wxapp/trunk/code/ 使用域账户验证身份 SVN类似于VS2010的TFS，但有几点需要注意： check out即获取一份本地拷贝，与TFS的映射类似 新增文件时，需要先add，再commit；同理，手动删除文件后，要先在SVN中delete，再commit 勤提交，多注释，遇到冲突先沟通再解决 "},"basic/es6.html":{"url":"basic/es6.html","title":"ES6","keywords":"","body":"ES6 变量声明 const 和 let 不要用 var，而是用 const 和 let，分别表示常量和变量。不同于 var 的函数作用域，const 和 let 都是块级作用域。 const DELAY = 1000;//常量 let count = 0;//块级变量 count = count + 1; 模板字符串 模板字符串提供了另一种做字符串组合的方法。 const user = 'world'; console.log(`hello ${user}`); // hello world // 多行 const content = ` Hello ${firstName}, Thanks for ordering ${qty} tickets to ${event}. `; 默认参数 在ES6中可以设置参数的缺省值 function logActivity(activity = 'skiing') { console.log(activity); } logActivity(); // skiing 箭头函数 函数的快捷写法，不需要通过 function 关键字创建函数，并且还可以省略 return关键字。 同时，箭头函数还会继承当前上下文的 this 关键字，不需要进行绑定(bind)操作。 class A extends React.Component { onClick = () => { console.log('clicked') } render() { return } } function写法： class A extends React.Component { onClick() { console.log('clicked') } render() { return } } 箭头函数还可以省略return关键字，当箭头右侧不指定花括号{}的时候，表示return箭头右测的表达式 let foo = () => () => console.log('gg') //等价于 let foo = () => { return () => { return console.log('gg'); } } //等价于 function foo() { return function() { return console.log('gg'); } } 模块的导入和导出 import 用于引入模块，export 用于导出模块。 例如: // 默认导出类 export default class App extends React.Component {}; // 或者 export default App; // 引入默认 import App from 'app'; //导出部分 const HEIGHT = 100; const WIDTH = 100; export { HEIGHT, WIDTH } // 引入部分 import { HEIGHT, WIDTH } from 'constants'; // 引入全部并作为 CONSTANTS 对象 import * as CONSTANTS from 'constants'; //引用宽高 CONSTANTS.HEIGHT CONSTANTS.WIDTH ES6 对象和数组 析构赋值 析构赋值让我们从 Object 或 Array 里取部分数据存为变量。 // 对象 const user = { name: 'guanguan', age: 2 }; const { name, age } = user; console.log(`${name} : ${age}`); // guanguan : 2 // 数组 const arr = [1, 2]; const [foo, bar] = arr; console.log(foo); // 1 我们也可以析构传入的函数参数。 const add = (state, { payload }) => { return state.concat(payload); }; 析构时还可以配 alias，让代码更具有语义。 const add = (state, { payload: todo }) => { return state.concat(todo); }; 对象字面量改进 这是析构的反向操作，用于重新组织一个 Object 。 const name = 'duoduo'; const age = 8; const user = { name, age }; // { name: 'duoduo', age: 8 } 定义对象方法时，还可以省去 function 关键字。 app.model({ reducers: { add() {} // 等同于 add: function() {} }, effects: { *addRemote() {} // 等同于 addRemote: function*() {} }, }); 展开符号Spread Operator Spread Operator 即 3 个点 ...，有几种不同的使用方法。 可用于组装数组。 const todos = ['Learn dva']; [...todos, 'Learn antd']; // ['Learn dva', 'Learn antd'] 也可用于获取数组的部分项。 const arr = ['a', 'b', 'c']; const [first, ...rest] = arr; rest; // ['b', 'c'] // With ignore const [first, , ...rest] = arr; rest; // ['c'] 还可收集函数参数为数组。 function directions(first, ...rest) { console.log(rest); } directions('a', 'b', 'c'); // ['b', 'c']; 代替 apply。 function foo(x, y, z) {} const args = [1,2,3]; // 下面两句效果相同 foo.apply(null, args); foo(...args); 对于 Object 而言，用于组合成新的 Object 。(ES2017 stage-2 proposal) const foo = { a: 1, b: 2, }; const bar = { b: 3, c: 2, }; const d = 4; const ret = { ...foo, ...bar, d }; // { a:1, b:3, c:2, d:4 } 此外，在 JSX 中 Spread Operator 还可用于扩展 props，详见展开属性 Promise Promise 用于更优雅地处理异步请求。比如发起异步请求： fetch('/api/todos') .then(res => res.json()) .then(data => ({ data })) .catch(err => ({ err })); 定义 Promise 。 const delay = (timeout) => { return new Promise(resolve => { setTimeout(resolve, timeout); }); }; delay(1000).then(_ => { console.log('executed'); }); Generators dva 的 effects 是通过 generator 组织的。Generator 返回的是迭代器，通过 yield 关键字实现暂停功能。只有当yield后面的方法返回结果时才会执行下一行代码 这是一个典型的 dva effect，通过 yield 把异步逻辑通过同步的方式组织起来。 app.model({ namespace: 'todos', effects: { *addRemote({ payload: todo }, { put, call }) { yield call(addTodo, todo); yield put({ type: 'add', payload: todo }); }, }, }); 在effect内要使用try/catch语句捕获异常 *addRemote({ payload: todo }, { put, call }) { try { yield call(addTodo, todo); yield put({ type: 'add', payload: todo }); }catch(err) { console.error(err) } } "},"basic/reactjs.html":{"url":"basic/reactjs.html","title":"ReactJS","keywords":"","body":"ReactJS Stateless Functional Components React Component 有 3 种定义方式，分别是 React.createClass, class 和 Stateless Functional Component。推荐尽量使用最后一种，保持简洁和无状态。这是函数，不是 Object，没有 this 作用域，是 纯函数。 比如定义 App Component function App(props) { function handleClick() { props.dispatch({ type: 'app/create' }); } return ${props.name} } 等同于： class App extends React.Componnet { handleClick() { this.props.dispatch({ type: 'app/create' }); } render() { return ${this.props.name} } } JSX语法规则 Component 嵌套 类似 HTML，JSX 里可以给组件添加子组件 className class 是保留词，所以添加样式时，需用 className 代替 class 。 Hello dva JavaScript 表达式 JavaScript 表达式需要用 {} 括起来，会执行并返回结果。 比如： { this.props.title } Mapping Arrays to JSX 可以把数组映射为 JSX 元素列表。 { this.props.todos.map((todo, i) => {todo}) } 注释 尽量别用 // 做单行注释。 {/* multiline comment */} {/* multi line comment */} { // single line } Hello 展开属性Spread Attributes 这是 JSX 从 ECMAScript6 借鉴过来的很有用的特性，用于扩充组件 props 。 比如： const attrs = { href: 'http://example.org', target: '_blank', }; Hello 等同于 const attrs = { href: 'http://example.org', target: '_blank', }; Hello Props属性 数据处理在 React 中是非常重要的概念之一，分别可以通过 props, state 和 context 来处理数据。而在 dva 应用里，你只需关心 props 。 propTypes和defaultProps JavaScript 是弱类型语言，所以请尽量声明 propTypes 对 props 进行校验，以减少不必要的问题。 function App(props) { return {props.name}; } App.propTypes = { name: React.PropTypes.string.isRequired, }; App.defaultProps = { name: 'abc' } 内置的 prop type 有： PropTypes.array PropTypes.bool PropTypes.func PropTypes.number PropTypes.object PropTypes.string CSS Modules 在React中使用CSS是通过CSS Modules来实现的，例如： app.css: . button { border-radius: 4px; background-color: LightCyan; } app.js import React from 'react'; import styles from './app.css'; function App(props) { return ( button ) } export default App; Inline Styles 还有一种定义样式的方法，使用内联样式( inline style)，定义styles的时候使用的对象的形式，样式名称跟css略有不同，移除了-，使用驼峰法命名，例如： import React from 'react'; const styles = { button: { backgroundColor: '#fff', borderRadius: 4 } } function App(props) { return ( button ) } export default App; CSS终极解决方案 引入reactCSS库 定义样式 import reactCSS from 'reactcss' const styles = reactCSS({ 'default': { card: { background: this.props.background, boxShadow: '0 2px 4px rgba(0,0,0,.15)', }, }, }) 内联方式引用 "},"basic/reduxjs.html":{"url":"basic/reduxjs.html","title":"ReduxJS","keywords":"","body":"ReduxJS 认识Redux之前要理解React中的状态(state)。 class App extends Component { state = { loading: false } render() { return ( { this.setState({loading: !loading}); }}/> ) } } 在上面的例子中，Button的loading属性就是由App的状态决定的，点击Button可以改变状态从而决定Button是否处于loading中。 ReduxJS(简称Redux)可以创建一个在React应用管理状态(state)的容器，它有Store，Action，Reducer这些概念。而Store就是状态(state)的容器。 Action Action是一个抽象的概念，可以理解为一个动作，比如按钮的点击，列表的选择。一个事件触发一个Action，以此来更改状态(state)。Action概念是以对象(object)的形式具现化的，而且有固定的格式： { type: 'save', payload: { loading: true } } 备注type是这个Action的类型，比如save就是保存状态Action；payload是‘负载’，即这个Action携带了什么，既然要保存，那肯定要有被保存的数据，payload就是携带这些数据的 而一个Action通常是通过dispatch方法来分发的，dispatch方法会自动映射到类的属性中。 class App extends Component { render() { return ( { this.props.dispatch({type: 'save', payload: { loading: !this.props.loading }}) }}/> ) } } Reducer Reducer是用来处理被dispatch的Action的。它是一个函数，接受state和action，返回一个新的state。 function reducer(state, action) { if(action.type === 'save') { return { ...state, ...action.payload } } } 备注具体store,action,reducer之间是如何交互的，查看dva "},"framework/antd-mobile.html":{"url":"framework/antd-mobile.html","title":"antd-mobile","keywords":"","body":"antd-mobile antd-mobile是移动端的UI框架，具体的使用方法和DEMO查看官方文档 "},"framework/react-wxeap.html":{"url":"framework/react-wxeap.html","title":"react-wxeap","keywords":"","body":"react-wxeap react-wxeap是WxEAP平台的前端框架 它基于dva集成了redux, redux-saga, react-router， 将状态和路由进行统一管理，使用非常简单 安装 npm i react-wxeap --save 配置路由和数据模型 在入口文件进行配置 import { MobileApp } from 'react-wxeap'; let routes = [ { name: 'TasksList', path: '/', model: require('./models/tasksList'), component: require('./routes/TasksList') }, { name: 'TaskDetail', path: '/TaskDetail', model: require('./models/taskDetail'), component: require('./routes/TaskDetail'), createForm: true } ]; let options = { module: 'wxcsm', origin: 'http://192.168.0.92/WxSoft.EAP', auth: '/WxLoginIF.aspx?EmpNo=sy&EmpPassword=111111' } const app = new MobileApp(routes, options); app.start(); App(routes)(config) routes是所有路由配置的数组，config是配置api的对象 在代码中使用dispatch或者put进行路由跳转 dispatch(routerRedux.push({ pathname: '/TaskDetail', query: { taskId, taskTitle } })) yield put(routerRedux.push({ pathname: '/TaskDetail', query: { taskId, taskTitle } }) queryquery是查询对象，不支持对象嵌套，在浏览器中的形式为 http://.../#TaskDetial?taskId=1&taskTitle=xxx service service是存放网络请求的，一个业务对应一个方法，返回网络请求的结果 import { request } from 'react-wxeap'; export function query() { return request('/api/users'); } 在model的effects中使用，当出错时，data为null，当正常时，err为null const { data, err } = yield call(query); model model是用来存放一个视图的所有业务逻辑 export default { namespace: 'taskList', state: { data: {}, page: 1 }, reducers: { save(state, { payload }) { return { ...state, ...payload } }, }, effects: { *initFetch({ payload: { areId } }, { call, put, select }) { const { page } = yield select(state => state.taskList); const { data } = yield call(fetchData, { page, areId }); yield put({ type: 'save', payload: { data } }) } }, subscriptions: { setup({ dispatch, history }) { return history.listen(({ pathname, query }) => { if (pathname === '/') { dispatch({ type: 'initFetch', payload: query }); } }); }, }, }; 上面的代码是某个任务列表视图的模型，一旦路由到这个视图，那么他将自动获取数据，自动绑定到视图 model包含下面五个属性： namespace 模型名称，在状态容器(Store)的对象名，用于索引状态树 state state定义了一个视图的初始状态，例如data: {}，那么这个视图的初始数据就为空 reducers reducers是reducer的集合，用于处理action，dva会自动根据action的type映射到reducers的某个函数中 以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方。由 action 触发。 格式为 (state, action) => newState dispatch({ type: 'save', payload: { } }) //映射到reducers的save方法 save(state, action) { } effects effects是副作用，它的概念涉及到函数编程思想，这里不理解也没关系，把它当成reducers的一种，是用来进行异步网络请求的 以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 state。由 action 触发，可以触发 action，可以和服务器交互，可以获取全局 state 的数据等等。 格式为*(action, effects) => void dispatch({ type: 'initFetch', payload: { areId: 1 } }) //映射到effects的initFetch *initFetch({ payload: { areId } }, { select, call, put }) { const { page } = yield select(state => state.taskList); const { data } = yield call(fetchData, { page, areId }); yield put({ type: 'save', payload: { data } }) } 这里select, call, put是dva提供的异步工具 select用于获取当前的state call用于调用需要时间返回结果的方法，第一个参数是方法，后面的参数是该方法的参数 put的作用和dispatch相同 subscriptions 以 key/value 格式定义 subscription。subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。 格式为 ({ dispatch, history }, done) => unlistenFunction。 setup({ dispatch, history }) { return history.listen(({ pathname, query }) => { if (pathname === '/') { dispatch({ type: 'initFetch', payload: query }); } }); }, route route是我们看到的视图，它在入口文件作配置 给route绑定model 在ES6中，React使用高阶组件来代替mixins，两者都可以给一个对象赋予额外的属性，与视图绑定便利用了这个特性 import { bind } from 'react-wxeap'; function TaskDetail({ text }) { return {text} } const mapStateToProps = state => { return { text: state.text } } export default bind(mapStateToProps, { createForm: true })(TaskDetail); bind就是给TaskDetail这个视图注入model定义的state，和一些其他的属性（第二个参数传递） mapStateToProps用于映射state到TaskDetail的props中 "},"development/example.html":{"url":"development/example.html","title":"设备巡检列表","keywords":"","body":"设备巡检列表 介绍如何基于React WxEAP开发一个巡检列表，支持下拉刷新，上拉加载和筛选状态，效果如下 新建工程 通过SVN拷贝模板工程然后删除目录下的.svn文件，修改模板工程的名字，即可新建一个工程 地址: http://192.168.0.7:8080/svn/wxapp/trunk/code/MobileTemplate 用Visual Studio Code打开工程文件夹，VSCode会自动创建.vscode文件，以后在资源浏览器中，随意打开一个js文件即可打开整个工程 安装依赖 在工程目录下运行命令 npm install 运行程序 npm start 接下来就是用smr(service-model-route)三步法创建一个视图应用 创建service 在services文件夹下创建tasksList.js //services/tasksList.js import { request } from 'react-wxeap-mobile'; import { PAGE_SIZE } from '../constants'; //export一个叫`fetchList`方法, 返回通过`request`请求到的数据 export function fetchList({ selectedIndex, page }) { return request(`${API}csmequip/QueryTasks?page=${page}&pageSize=${PAGE_SIZE}&state=${selectedIndex}`); } 创建model 在models文件夹下创建tasksList.js import { fetchList } from '../services/tasksList'; import { PAGE_SIZE } from '../constants'; export default { namespace: 'tasksList', state: { selectedIndex: 0,/**当前条件（0-未完成，1-已完成） */ tasks: []/**当前已经获取到的任务 */ }, reducers: { save(state, { payload }) { return { ...state, ...payload } }, }, effects: { *fetch({ payload: { page, fill } }, { call, put, select }) { try { /**获取当前条件（未完成，已完成），和已经获取的任务 */ const { selectedIndex, tasks } = yield select(state => state.tasksList); /**根据当前页数和状态获取任务 */ const { data, err } = yield call(fetchList, { selectedIndex, page }) if(err) return /**组织新的任务列表，如果页数是1，代表刷新列表，否则拼接上原来的数据 */ let newTasks = (page === 1 ? data.tasks : [...tasks, ...data.tasks]); /**保存新的任务 */ yield put({ type: 'save', payload: { tasks: newTasks }}) /**填充数据到列表，包括是否加载完成 */ yield call(fill, newTasks, data.tasks.length 创建route 在Routes文件夹下新建一个TasksList.js，路由一般首字母大写 import React from 'react'; import { ListView, routerRedux, bind } from 'react-wxeap'; import { PAGE_SIZE } from '../constants' import { SegmentedControl, WingBlank, List, RefreshControl } from 'antd-mobile'; const Item = List.Item; const Brief = Item.Brief; const styles = { container: { backgroundColor: '#fff' }, wingBlank: { paddingTop: 30, paddingBottom: 30 } } class TasksList extends React.Component { onFetch = (page, fill) => { this.props.dispatch({ type: 'tasksList/fetch', payload: { page, fill } }) } onIndexChange = e => { this.props.dispatch({ type: 'tasksList/save', payload: { selectedIndex: e.nativeEvent.selectedSegmentIndex } }) this.listView.reload(); } onItemClick = (rowData) => { const { taskId, taskTitle, taskDate, taskEquipNum } = rowData; const { dataSource } = this.props; let taskIds = \"\"; dataSource.map((item, index) => { taskIds += item.taskId if (index !== dataSource.length - 1) { taskIds += \",\" } }) this.props.dispatch(routerRedux.push({ pathname: '/TaskDetail', query: { taskId, taskTitle, taskIds } })) } getTaskStateString = (taskState) => { switch (taskState) { case 0: return '未开始' case 1: return '进行中' case 2: return '已完成' default: return '' } } render() { const { dispatch, selectedIndex } = this.props; const renderRow = (rowData, sectionID, rowID) => this.onItemClick(rowData)}> {rowData.taskTitle} {rowData.taskDate + ` ` + this.getTaskStateString(rowData.taskState) + ` ` + rowData.taskEquipNum} return ( this.listView = o} header=\"巡检任务列表\" renderRow={renderRow} pageSize={PAGE_SIZE} onFetch={this.onFetch} />} />}/> ); } } const mapStateToProps = state => { const { list } = state.tasksList; return { dataSource: list, ...state.tasksList }; } export default bind(mapStateToProps)(TasksList); 在入口文件index.js修改配置 import { MobileApp } from 'react-wxeap'; let routes = [ { name: 'TasksList', path: '/', model: require('./models/tasksList'), component: require('./routes/TasksList') }, { name: 'TaskDetail', path: '/TaskDetail', model: require('./models/taskDetail'), component: require('./routes/TaskDetail'), createForm: true } ]; let options = { module: 'wxcsm', origin: 'http://192.168.0.92/WxSoft.EAP', auth: '/WxLoginIF.aspx?EmpNo=sy&EmpPassword=111111' } const app = new MobileApp(routes, options); app.start(); 调试与打包 使用chrome打开调试服务器，打开chrome的开发者工具，切换为移动模式，即可调试 运行下面的命令会将应用打包成静态文件，API路径会自动转至生产环境 npm run build 然后在dist文件夹下面就会出现打包压缩后的应用，放入WxEAP后才能正常运行 "}}